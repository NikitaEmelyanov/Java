package AlgorithmsAndDataStructures;

/**
 * Урок 8. Жадные алгоритмы. Задача о рюкзаке
 */
public class Les8_Greedy_Algorithms_Fractional_knapsack_problem {
    public static void main(String[] args) {
        //Хоти максимизировать количество калорий, которые возьмем с собой. При этом любой из
        // объектов можно делить на части (fractional knapsack)

        //Входные данные
        // - Веса предметов w1, w2, ... , wn
        // - Ценность каждого предмета (Калории, цена и т.д.) v1, v2, ... ,vn
        // - Вместительность рюкзака W
        // - Количество объектов N

        //Выходные данные
        // - Максимальное значение ценности, которое помещается в рюкзак с вместительностью W

        //Пример
        // Предмет     Цена       Вес
        // 1            20$        4
        // 2            18$        3
        // 3            14$        2
        //Вместительность рюкзака 7

        //Варианты решения
        // 1) можно взять полностью 1 и 2 второй предмет и получить суммарную ценность 38$
        // 2) можно взять полностью 1 и 3 третий предметы и добавить 1/3 от предмета 2. Тем самым
        // получим суммарную ценность 40$
        // 3) можно взять полностью 2 и 3 предметы и половину от предмета 1. Получим ценность 42$

        //Для решения задачи нужно придумать оптимальное локальное решение, которое является
        // безопасным ходом, то есть приводит к глобально оптимальному решению

        //Для решения задачи жадным алгоритмом, необходимо отсортировать вещи по их удельной ценности
        // (то есть отношению ценности предмета к его весу)б и поместить в рюкзак предметы с
        // наибольшей удельной ценностью.
        // Предмет     Цена       Вес     Удельная ценность
        // 1            20$        4       20$ / 4 = 5$ (за 1)
        // 2            18$        3       18$ / 3 = 6$ (за 1)
        // 3            14$        2       14$ / 2 = 7$ (за 1) - самая большая удельная ценность
        //Жадный алгоритм
        // 1) Отсортировать объекты по их удельной ценности
        // 2) Выбрать объект с наибольшей удельной ценностью
        // 3) если объект помещается в рюкзак полностью - положить этот объект в рюкзак
        // 4) Если объект не помещается в рюкзак полностью, взять такую часть этого объекта,
        // которая заполнит рюкзак
        // 5) Вернуть полученную общую ценность

        //Сложность алгоритма
        // - Сортировка удельных ценностей объекта - O(N*log(N)
        // - Вычисление того, сколько объектов поместиться в рюкзак - O(N)
        // - Итоговая сложность O(N*log(N))+o(N) = O(N*log(N)
        // Где N - количество существующих объектов



        // Переформулируем условия задачи, чтобы наш жадный алгоритм больше не мог давать правильный
        // ответ
        //Предположим, что объекты неделимые - discrete knapsack problem. Мы можем либо взять объект,
        // либо не взять
        // Предмет     Цена       Вес     Удельная ценность
        // 1            30$        6       5$
        // 2            14$        3       4.66$
        // 3            16$        4       4$
        // 4             9$        2       4.5$
        //Вместительность рюкзака 10
        //Таким образом если использовать предыдущий жадный алгоритм с удельной ценностью, будут
        // взяты 1 и второй предметы. Итоговая ценность составит 44$ и останется пустое место
        // Для решения этой задачи используется другой подход - Динамическое программирование.
        // При использовании динамического программирования будет возможно взять первый и третий
        // объекты. Суммарная ценность составит 46$

    }

}
