package AlgorithmsAndDataStructures;
/**
 * Урок 2. Мемоизация
 */

import java.util.Arrays;

public class Les2_Memoization {
    public static void main(String[] args) {
        //Мемоизация (англ. Запоминание) - сохранение результатов выполнения функции для
        // предотвращения повторных вычислений

        int n = 100;
        //Сначала нужно завести переменную и приравнять ее к числу Фибоначчи, а не передавать число
        // напрямую
        long[] mem = new long[n+1];
        //Создадим массив long и передадим его в качестве второго аргумента. В данном массиве и
        // будет происходить запоминание
        Arrays.fill(mem,-1);
        //fill() - Статический метод позволяющий заполнить весь массив одинаковыми числами, в
        // качестве аргумента нужно передать название массива и число для заполнения

        System.out.println("Рекурсивный метод с использованием мемоизации: "+fibNaive(n,mem));
    }

    private static long fibNaive(int n, long[] mem) {
        if (mem[n] !=-1)
            return mem[n];
        //Данная конструкция говорит о том что, если значение в методе fibNaive = -1, значит метод
        // с таким значением еще не вызывался, если значение не будет равно -1, значит метод с
        // таким значением уже вызывался и нужно вернуться к исходному значению, что даст
        // возможность исключить повторы вычислений

        if (n == 0)
            return 0;
        if (n == 1)
            return 1;

        long result =  fibNaive(n - 1,mem) + fibNaive(n - 2,mem);
        mem[n] = result;
        return  result;
        // Тут тоже изменилась конструкция, теперь результат помещается в переменную, которая и
        // будет записываться в массив и после чего возвращаться
    }
}
