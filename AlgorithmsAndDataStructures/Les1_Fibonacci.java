package AlgorithmsAndDataStructures;

/**
 * Числа Фибоначчи
 * Fn = 0              , n = 0.
 * Fn = 1              , n = 1.
 * Fn = F n-1  +  F n-2, n > 1.
 *
 * 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 114
 * При n>1 Число Фибоначчи(Fn) равно сумме двух предыдущих чисел
 */
public class Les1_Fibonacci {
    //Числа Фибоначчи - это математическая модель, описывающая размножение кроликов

    //В место огороженное со всех сторон стеной, поместили пару кроликов, природа которых такова, что
    //любая пара кроликов производит на свет другую пару кроликов каждый месяц, начиная со второго
    // месяца своего существования. Сколько пар кроликов будет через год ? (Ответ 233 пары)

    //Числа Фибоначчи растут очень быстро
    //F20 = 6765
    //F50 = 12586269025
    //F100 = 354224848179261915075
    //F200 = 280571172992510140037611932413038677189525
    public static void main(String[] args) {
        System.out.println(fibNaive(3));
        System.out.println(fibNaive(5));
        System.out.println(fibNaive(10));

        System.out.println(fibEffective(100));
    }
    //Наивный, медленный, Очевидный
        private static long fibNaive (int n){
            if (n==0)
                return 0;
            if (n==1)
                return 1;

            return fibNaive(n-1) + fibNaive(n-2); // Рекурсивный вызов
        //Алгоритм настолько не эффективный и медленный, что для вычисления 100 числа Фибоначчи
        // потребуется примерно 50000 лет
        //                                 Fn
        //                        /                \
        //                   Fn-1                    Fn-2
        //                  /    \                /        \
        //              Fn-2      Fn-3         Fn-3         Fn-4
        //            /     \    /     \      /    \      /      \
        //           Fn-3  Fn-4  Fn-4  Fn-5  Fn-4  Fn-5  Fn-5  Fn-6
        //                                ...
        //Основная причина долгого вычисления это дублирование вычислений, плюс ко всему древо
        // разрастается в геометрической прогрессии и каждое колено будет добавлять в два раза
        // больше вычислений относительно предыдущего. Так же в геометрической прогрессии будут
        // множиться ненужные вычисления
    }
    private static long fibEffective (int n){
        long[] arr = new long [n+1];
        arr[0] = 0;
        arr[1] = 1;

        for (int i = 2; i <= n; i++)
            arr[i] = arr[i-1] + arr[i-2];

            return arr[n];
            //Не совершается ни одного ненужного вычисления. Путем создания массива мы увеличили
        // затраты памяти, но невообразимо увеличиваем скорость вычисления 50000 лет по отношению
        // к нескольким секундам

    }
}
