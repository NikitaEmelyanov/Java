package AlgorithmsAndDataStructures;

/**
 * Урок 3. Большое О (Big O Notation). Сложность алгоритма. Часть 1.
 */

public class Les3_Big_O_notation_Part_1 {
    public static void main(String[] args) {
        //Для того чтобы сравнивать алгоритмы нам надо научиться измерять их быстродействие

        //Подходы к измерению быстродействия:
        //-Измерить количество времени, затрачиваемое на выполнение каждой строки программы
        // (очень сложно, зависит от ЯП и архитектуры системы)
        //-Выполнить программу на реальном компьютере и замерить время исполнения (быстродействие
        // алгоритма будет зависеть от мощности компьютера, архитектуры ОС, компилятора и других мелочей)

        //На практике мы не можем точно измерить время работы алгоритма (слишком много переменных)

        //Но нам достаточно узнать примерное время работы программы (чтобы отличить, например
        // fibNaive() от fibEffective())

        //Способ измерения не должен требовать знания об устройстве компьютера, архитектуре ОС,
        // версии компилятора


        //Идея

        //Все эти детали (мощность компьютера, версии компилятора, архитектура ОС)
        // увеличивают/уменьшают быстродействие алгоритма на константу

        //Пример:
        //-Запустили fibNaive() на обычном компьютере (мощность х)
        //-Запустили fibNaive() на суперкомпьютере (мощность 100х)
        //-Время выполнения fibNaive() на обычном Пк = у секунд
        //-Время выполнения fibNaive() на суперкомпьютере = (1/100)*у секунд
        //(1/100) - Константа не зависит от аргумента n

        //Идея
        //Будем игнорировать константы (Мощность компьютера, ЯП, архитектура системы, компилятор),
        // они не так важны при увеличении аргумента

        //Однако 1 год и 1 секунда тоже различаются лишь на константу, но в нашем способе измерения
        // это вроде одно и то же
        //1 год = 31536000*1секунду
        //31536000 - константа
        //Идея не в том, чтобы измерять время выполнения алгоритма6 а измерять такую характеристику
        // как асимптотическое время выполнения алгоритма

        //Асимптотическое время выполнения
        //Асимптотика - поведение функции при стремлении аргумента к бесконечности
        //Поведение fibNaive() при стремлении к бесконечности, например
        //         n       nlogn     n^2        2^n
        //n=20     1sec    1sec      1sec       1sec
        //n=50     1sec    1sec      1sec       13day
        //n=10^2   1sec    1sec      1sec       4*10^3 year
        //n=10^6   1sec    1sec      17min
        //n=10^9   1sec    30sec     30year
        //max n    10^9    10^7,5    10^4,5       30
        //Эта характеристика описывает, как алгоритм будет работать на очень больших аргументах и
        // этого нам достаточно, чтобы отличить эффективный алгоритм от неэффективного
        //Мы не думаем о константах потому что при достаточно большом n
        //n*log(n)>1000000000000000000*n
        //n^2>1000000000000000000*n
        //2^n>1000000000000000000*n^2


            System.out.println(fibNaive(3));
            System.out.println(fibNaive(5));
            System.out.println(fibNaive(10));

            System.out.println(fibEffective(100));
        }
        //Наивный, медленный, Очевидный
        //O(2^n)
        private static long fibNaive (int n){
            if (n==0)
                return 0;
            if (n==1)
                return 1;

            return fibNaive(n-1) + fibNaive(n-2);
        }
        //O(n) - асимптотическая оценка (сложность)
    //Обозначается как большое О от n, то есть время выполнения будет расти пропорционально аргументу
        private static long fibEffective (int n){
        //O(n) тут тоже сложность будет O(n)
            long[] arr = new long [n+1];
            arr[0] = 0;
            arr[1] = 1;

            //Соответственно общая сложность O(n+n) => O(2n) =>O(n), поскольку константы не
            // рассматриваются
            for (int i = 2; i <= n; i++)
                arr[i] = arr[i-1] + arr[i-2];

            return arr[n];
        }
    }
//Наиболее частые значения:
//logn < корень из n < n < nlogn < n^2 < 2^n
//log(100) = 6
//sqrt (100) = 10
//100 = 100
//100* log(100) = 600
//100^2 = 10000
//2^100 = 12676506000228229401496703205376