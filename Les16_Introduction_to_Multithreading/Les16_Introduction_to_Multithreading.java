package Les16_Introduction_to_Multithreading;

public class Les16_Introduction_to_Multithreading {
    public static void main(String[] args) throws InterruptedException {
        //Урок 16: Введение в многопоточность в Java

        //Многопоточность позволяет выполнять несколько участков кода одновременно, а если
        //точнее, то процессор(если ядро одно) переключается очень быстро между отрезками
        // кода выполняя их параллельно, это называется виртуальной параллельностью. Если
        //ядер процессора несколько, то Java распределяет выполнение каждого участка кода
        // на отдельное ядро процессора
        MyThread myThread = new MyThread();
        myThread.start();
        //Метод start() класса Thread создает новый поток и выполняет то, что описано в
        //методу run(). Сам метод run() не нужно запускать, он для внутреннего использования
        //для запуска второго потока ОБЯЗАТЕЛЬНО нужно использовать метод start()
        MyThread myThread1 = new MyThread();
        myThread1.start();
        //Для создания еще одного потока не обязательно создавать новый класс, а можно
        //создать новый объект класса, метод start() обработает новый объект в отдельном
        // потоке. Поскольку потоки не синхронизированы, они все борятся за процессорное
        // время, по этому возможно что потоки будут перехватывать инициативу друг у друга
        System.out.println("Hello from main Thread");
        //Поскольку потоки в Java не синхронизированы, они могут выполняться в любом
        // порядке, это можно увидеть если несколько раз запустить главный поток и можно
        //будет заметить что иногда выводится 100 раз Hello my Thread, а потом уже
        //Hello from main Thread, а иногда наоборот

        Thread thread = new Thread(new Runner());
        //Способ №. Создаем новый объект на основе класса Thread, который реализует
        //интерфейс Runnable с названием класса в качестве аргумента
        thread.start();

        System.out.println("I am going to sleep");
        Thread.sleep(3000);
        // Метод sleep (миллисекунды) класса Thread позволяет потоку "уснуть" на время
        System.out.println("I am awake!");
    }
}
class MyThread extends Thread{
    // Создание еще одного потока (Способ №1) - унаследовать все от класса Thread
    public void run(){
        //Чтобы выполнять код в отдельном потоке, наследуя от Thread нужно переопределить
        // метод run(), класса Thread 
        for (int i = 0; i < 100; i++) {
            try {
                Thread.sleep(100);
                //При таком использовании sleep() потоки будут более менее
                // синхронизированы
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("Hello my Thread "+ i);
        }
    }
}
class Runner implements Runnable{
    // Создание еще одного потока (Способ №2) - реализация интерфейса Runnable, а потом
    //при создании нового потока устанавливаем название класса, который реализует
    // интерфейс Runnable в качестве аргумента для нового потока
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("Способ №2");
        }

    }
}
//Программа не завершит свою работу пока все потоки этой программы не завершат свои части
//кода