package JavaPRO;

public class Les18_synchronized_Part_1 {
    private int counter;

    public static void main(String[] args) throws InterruptedException {
        //Урок 18: Ключевое слово synchronized (I часть)
        Les18_synchronized_Part_1 test = new Les18_synchronized_Part_1();
        test.doWork();
    }
    public synchronized void increment(){
        //Ключевое слово synchronized говорит о том, что все что находиться в теле метода может
        // выполнять только один поток, то есть 2 потока в одно и то же время уже не могут
        // выполнять инкрементацию
        counter++;
    }
    public void doWork() throws InterruptedException {
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10000; i++) {
                    increment();
                }
            }
        });
        //Чтобы не создавать новый класс и на основе его создавать переменные, можно воспользоваться
        // анонимным классом и передать его в качестве аргумента
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10000; i++)
                    increment();
            }
        });
        thread1.start();
        thread2.start();

        thread1.join(); //Метод позволяющий подождать пока поток завершит работу, при этом main
        // приостанавливается и ждет пока поток полностью не завершится
        thread2.join();
        //Учитывая, что у нас 2 потока должны инкрементировать counter по 10000 (суммарно должно
        // получиться 20000), вывод на экран не всегда будет показывать значение 20000, поскольку
        // оба потока находятся в состоянии гонки (Race condition) и одновременно записывают данные
        // в одну переменную часть инкрементов может потеряться, так как операция инкриминирования
        // не атомарна (не не делима) а состоит из 3 операций (считывание, увеличение на 1 и
        // помещение новой переменной в старую), а каждая из этих операций занимает время. Поскольку
        // потоки не синхронизированы и могут перехватывать инициативу и образуется это состояние
        // гонки, для избежания такого состояния нужно пользоваться ключевым словом synchronized,
        // но его нельзя прописывать в переменную, а можно прописывать только в методе, поэтому
        // заменим прямую инкрементацию на метод increment(), который будет выполнять данную функцию
        System.out.println(counter);
    }
}
